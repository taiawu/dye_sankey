---
title: "Dye Sankey Diagram"
output: html_notebook
---

This is an R notebook dedicated to figuring out the best way to make a Sankey diagram for the dye paper. 

Will explore at least: 
- networkD3 (typical sankey package)
- ggplot with geom_smooth and scale_color_viridis_d 

```{r}
library(tidyverse)

make_node <- function( df, 
                       filter_var = NULL, 
                       node_group = NULL, 
                       node_name, 
                       xvalue_in, 
                       distinct_var # variable to make distinct within the node (useful if an entity is included in multiple nodes)
                       ){
  
                    filter_call <- rlang::parse_expr(filter_var)
                    distinct_call <- rlang::parse_expr(distinct_var)
                    
                    df %>% 
                        ungroup() %>%
                        filter(!!filter_call) %>%
                        distinct(!!distinct_call, .keep_all = TRUE) %>%
                        mutate(node_group = node_group,
                               node_name = node_name,
                               xvalue = xvalue_in) 
                          }

make_node_map <- function(df, var_list) {
                                make_node( df, 
                                           filter_var = var_list$filter_var, 
                                           node_group = var_list$node_group,
                                           node_name = var_list$node_name, 
                                           xvalue_in = var_list$xvalue_in, 
                                           distinct_var = "dye")
                              }

nudge_node <- function(df, 
                       .corr_col, 
                       .filter_col,  
                       filt_var, 
                       rep_var,
                       overwrite = FALSE ) {
  
  # https://community.rstudio.com/t/using-mutate-in-a-function-with-the-new-colname-as-an-argument/10399/2
  #  https://dplyr.tidyverse.org/reference/recode.html
  filter_col <- enquo(.filter_col)
  corr_col <- enquo(.corr_col)
  new_corr_name <- quo_name(corr_col)
  
  # GGG_levels <- c(0, 1, 2, 3, 4, 5)
  df <- df %>% 
          mutate(temp = !!corr_col) %>% ## THIS SUCKS part 1
          mutate(!!new_corr_name := replace( !!corr_col, !!filter_col == !!filt_var, rep_var)) %>%
          mutate(!!new_corr_name := !!corr_col + temp) %>% ## THIS SUCKS part 2
          select(-temp) ## THIS SUCKS part 3
  
  if (overwrite == TRUE) {
    print("overwriting")
      df <- df %>% 
          mutate(!!new_corr_name := replace( !!corr_col, !!filter_col == !!filt_var, rep_var))
    
  }

  df 
}

ggsankey <- function( nodes, 
                      x_variable = xvalue_final, 
                      y_variable = yvalue_final,
                      group_variable = dye,
                      color_variable = dye_order_num,
                      color_filter = "detect_ever == 1 & reject_buffer != 1"
                      ) {

  x_var <- enquo(x_variable)
  y_var <- enquo(y_variable)
  group_var <- enquo(group_variable)
  color_var <- enquo(color_variable)
  color_filter <- rlang::parse_expr(color_filter)
  
  nodes %>%
      ungroup() %>%
     filter(!!color_filter) %>%
    
      ggplot(     ) + 
      geom_line(data = nodes,
                 aes(x = !!x_var, y = !!y_var, group = !!group_var), size = 0.2, alpha = 0.7, color = "lightgrey") +

    geom_line(data = nodes %>% filter(reject_buffer == 1),
                aes(x = !!x_var, y = !!y_var, group = !!group_var), size = 0.2, alpha = 0.7, color = "darkgrey") +
      
    geom_line( aes(x = !!x_var, y = !!y_var,  color = !!color_var , group = !!group_var), 
                 size = 0.3, alpha = 1) +
    
    scale_color_viridis_c() 
}
```

Read in the raw data
```{r}
# the initial df must contain all varaibles necessary to filter to create the nodes for the Sankey
df <- readRDS("Exp0810--20200527_dye_hit_rate_after_recall.rds") %>% # dye name, tanimoto order, and and hit rate data
      left_join(read_csv("Exp0810--20200416_all_screen_hits_v5.csv") %>% select(dye, detect_ever, reject_buffer)) %>% # manually curated triage calls
      left_join(read_csv("Exp0863--20200807_sankey_dye_data.csv") %>% select(Class, dye)) %>% # just classes associated with the dye names (A, C, T ...)
      arrange(Class, dye_order_num) 

# read create nodes from the input data and a list of nodes 
nodes <- read_csv("Exp0863--20200807_nodes.csv") %>%
          pivot_longer(cols= c(xvalue_var, xvalue_var2), names_to = "node_end", values_to = "xvalue_in")%>%
          split( . , seq(nrow( . ))) %>%
          lapply(as.list) %>%
  
          lapply( . , make_node_map, df = df) %>% # make the node map for each input node info list
          bind_rows() %>% # bind together into a single tibble
  
          group_by(xvalue) %>% # these groupings create the inter-node order AND quantitative heights
          arrange(dye_order_num) %>%
          mutate(yvalue = row_number(),
                 y_correction = 0,
                 x_correction = 0) %>%
          mutate(yvalue_center = median(yvalue)) %>%
          mutate(yvalue_final = yvalue + y_correction - yvalue_center) %>%
          mutate(xvalue_final = xvalue + x_correction)
```


Visualize and nudge nodes
```{r}
 # create a tibble of nudges to lapply call 
# nudges <- tribble(
# 
# )

nodes %>%
 nudge_node( . , .filter_col = node_group, .corr_col = yvalue_final, filt_var = "start", rep_var = -500, overwrite  = FALSE) %>% 
  #nudge_node( . , .filter_col = node_name, .corr_col = yvalue_final, filt_var = "add_T", rep_var = 400, overwrite  = FALSE) %>% 
  nudge_node( . , .filter_col = node_group, .corr_col = yvalue_final, filt_var = "tech1", rep_var = 300, overwrite  = FALSE) %>% 
  nudge_node( . , .filter_col = node_group, .corr_col = xvalue_final, filt_var = "tech1", rep_var = 40, overwrite  = FALSE) %>% 

  ggsankey( . , xvalue_final, yvalue_final) + 
  theme_void()

```









Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

